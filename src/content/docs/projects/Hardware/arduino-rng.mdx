---
title: "Arduino RNG"
description: "Arduino + Python"
pubDate: "Jan 11 2026"
---

This article is well-structured and informative, but the tone and some explanations waver between being overly academic and overly casual. For a tech-savvy audience, we can sharpen it to be more direct, precise, and engaging.

Here is a revised version that maintains the technical depth while improving clarity, flow, and appeal for a knowledgeable reader.

---

title: "Building a Hardware-in-the-Loop HFT Simulator with Arduino and Python"
description: "A low-latency simulator using an Arduino as a mock exchange, a Python engine for analytics, and real-time risk controls."
pubDate: "Jan 11 2026"

# **High-Frequency Trading (HFT) Hardware-in-the-Loop Simulator**

This project simulates a low-latency trading system by connecting physical hardware (an Arduino) to a Python-based analytical engine. It demonstrates real-time binary data ingestion, multi-threaded concurrency, and automated risk mitigation in a unified hardware-software pipeline.

## **TL;DR: What This Does**

[Youtube Shorts Demo](https://www.youtube.com/shorts/VDHP2wRmV9Y)

1.  **Arduino as Mock Exchange:** Continuously broadcasts random price data in a custom binary packet format. An LDR (light sensor) influences "market volatility."
2.  **Python as Trading Engine:** Ingests the data, displays the current price on an LCD, and logs "trades" triggered by an Arduino button press.
3.  **Two-Way Communication:** Python sends commands back to the Arduino (e.g., for the LCD), and implements a **"Circuit Breaker"** that blocks trades during high volatility.
4.  **The Goal:** Experiment with ultra-fast, deterministic communication between a physical data source and a high-level analytical system.

## **ðŸš€ System Architecture: Producer-Consumer Pattern**

The core uses a **Producer-Consumer** pattern to separate I/O-bound operations from processing logic, ensuring consistent performance and zero data loss.

### **1. Hardware Layer: The Market Data Emulator (Arduino)**

- **Role:** Acts as a mock exchange, streaming price data.
- **Microcontroller:** Arduino Uno.
- **Protocol:** UART serial, pushed to **2,000,000 baud** for minimal latency.
- **Data Packet:** A lean, 6-byte binary frame for maximum efficiency:
  - **Format:** `[Header (0xAA) | 2-byte Sequence # | 2-byte Price | 1-byte Signal]`
- **Key Components:**
  - **LDR (Light Sensor):** Analog input that modulates data randomness, simulating market volatility.
  - **Button:** Triggers a "trade signal" in the data stream.
  - **I2C LCD:** Displays status messages and price data sent from Python.

**Snippet: Arduino Packet Transmission**

```cpp
// Construct and transmit the 6-byte binary packet
Serial.write(0xAA);                 // Header byte
Serial.write((uint8_t*)&seqNum, 2); // 2-byte sequence number
Serial.write((uint8_t*)&price, 2);  // 2-byte price
Serial.write(tradeSignal);          // 1-byte signal (e.g., button press)
```

### **2. Software Layer: The Analytical Engine (Python)**

- **Ingestion Thread (Producer):** A dedicated thread constantly reads the serial port, unpacking binary data using Python's `struct` module.
- **Processing & Control:** Manages the shared state, updates the LCD, and executes the trading logic.
- **Circuit Breaker:** A core risk-management feature. When the LDR indicates high "volatility," the system automatically blocks all trade executions.

**Snippet: Python Data Ingestion & Unpacking**

```python
if ser.in_waiting >= 6:
    raw = ser.read(6)
    if raw[0] == 0xAA:  # Validate packet header
        # Unpack: 1 Byte, 2-byte Unsigned Short, 2-byte Unsigned Short, 1 Byte
        header, seq, price, btn = struct.unpack("<BHHB", raw)
        with data_lock:  # Thread-safe update
            latest_data["price"] = price
            latest_data["seq"] = seq
            if btn == 1:
                latest_data["btn_signal"] = 1
```

**Snippet: Python Circuit Breaker Logic**

```python
# Execute trade only if the circuit breaker is NOT engaged
if curr_signal == 1:
    if system_locked:
        print(f"[REJECTED] Seq {curr_seq} | Blocked by Circuit Breaker!")
    else:
        print(f"[EXECUTE] Seq {curr_seq} | Price: ${curr_price / 100:.2f}")
```

## **ðŸ› ï¸ Technical Stack**

- **Languages:** Python 3.x, C++ (Arduino)
- **Communication:** UART (Serial at 2M baud), I2C (for LCD)
- **Key Python Libraries:** `pyserial`, `threading`, `struct`
- **Key Arduino Libraries:** `Wire.h`, `LiquidCrystal_I2C.h`

## **âš™ï¸ Key Engineering Details**

- **Binary Protocol Over ASCII/JSON:** Using raw byte packing/unpacking (`struct`) eliminates parsing overhead, achieving sub-millisecond latencyâ€”critical for HFT-like systems.
- **Thread-Safe Concurrency:** A mutex (`threading.Lock`) protects shared data between the serial-reading thread and the main processing thread, preventing race conditions.

**Snippet: Thread-Safe State Management in Python**

```python
# Global state shared between threads
latest_data = {"price": 0, "seq": -1, "btn_signal": 0}
data_lock = threading.Lock()  # Mutex for safe access

# In any thread, access data within a lock context
with data_lock:
    current_price = latest_data["price"]
    current_sequence = latest_data["seq"]
```

## **ðŸ“½ï¸ Demonstration & Output**

The system demo shows:

1.  **Normal Operation:** Steady data flow and price display on the LCD.
2.  **Trade Execution:** Immediate console logging when the Arduino button is pressed.
3.  **Volatility Simulation:** Covering the LDR triggers the "high volatility" state.
4.  **Risk Mitigation in Action:** During high volatility, the Circuit Breaker activates and subsequent button presses are logged as **REJECTED**.
